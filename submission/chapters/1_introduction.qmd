---
title: "Introduction"
format:
  html:
    toc: true
---

Life expectancy is a compact summary indicator of population health that reflects mortality across age groups and, indirectly, differences in disease burden, health-system access, and socio-economic conditions. We analyze the [“Life Expectancy (WHO)” dataset](https://www.kaggle.com/datasets/kumarajarshi/life-expectancy-who) published on Kaggle [@KumarRajarshi]. It is a country-year panel (193 countries, 2000–2015) with the target variable `life_expectancy` (years) and 20 candidate predictors spanning mortality burden, immunization, socio-economic development, and nutrition.

Our main goal is **explanatory and predictive regression**: (i) identify which predictors are most strongly associated with life expectancy (direction and magnitude), and (ii) quantify predictive performance out-of-sample. To reduce within-country temporal dependence, most multivariate analyses use a single cross-section (2014; see [Year Selection](2_preproc_year_selection.qmd)); regression models are evaluated on a separate holdout year (2011) in [Regression](5_regression.qmd), reporting predictive accuracy in years (RMSE) alongside explained variance ($R^2$). All findings are interpreted as descriptive associations in observational data (not causal effects).

# Research questions and chapter map

We address two questions:

1. **Which predictors (or predictor blocks) are most strongly associated with life expectancy** in a recent cross-section, once redundancy and data quality constraints are made explicit?
2. **How well do the resulting models generalize out-of-sample** to a different year?

The report follows the course workflow (preprocessing → descriptives → exploration → regression). This introduction summarizes the analysis views and a small set of descriptive and bivariate patterns that motivate the later chapters. Concretely:

1. **Choose a representative cross-section** and justify the 2014 framing ([Year Selection](2_preproc_year_selection.qmd)).
2. **Clean and transform the data**, documenting missingness and outlier sensitivity ([Data Cleaning & Preprocessing](2_preprocessing.qmd), [Outlier Detection](2_outlier_detection.qmd)).
3. **Validate the HDI-like column** to avoid target leakage in regression and model selection ([Investigate HDI](2_investigate_hdi.qmd)).
4. **Quantify redundancy and low-dimensional structure** via correlations and grouped PCA ([Correlation Analysis](3_correlation.qmd), [Principal Component Analysis](3_pca.qmd)).
5. **Explore country profiles** in standardized feature space ([Clustering](4_clustering.qmd)).
6. **Select parsimonious models** using transparent criteria and search strategies ([Model Selection](6_model_selection.qmd)).
7. **Fit and diagnose OLS models** and evaluate generalization to a holdout year ([Regression](5_regression.qmd)).
8. **Document limitations and open questions** for follow-up ([Open Questions](5_open_questions.qmd)).
```{python}
# | label: intro-setup
# | include: false
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from ama_tlbx.data import LECol, LifeExpectancyDataset
from ama_tlbx.data.utils import parse_column_docstrings
from ama_tlbx.utils.plotting_config import DEFAULT_PLOT_CFG

np.random.seed(42)
DEFAULT_PLOT_CFG.apply_global()

# Raw longitudinal panel
le_panel = LifeExpectancyDataset.from_csv(
    aggregate_by_country=False,
    drop_missing_target=False,
    resolve_nand_pred=False,
)
df_panel = le_panel.df
panel_pred_cols = le_panel.feature_columns(include_target=False)
panel_missing_features = int(df_panel[panel_pred_cols].isna().any(axis=0).sum())

# Life expectancy time series (panel; mean across countries with 95% CI)
panel_lifeexp = (
    df_panel[[LECol.YEAR, LECol.LIFE_EXPECTANCY]]
    .dropna(subset=[LECol.LIFE_EXPECTANCY])
    .assign(year=lambda d: d[LECol.YEAR].dt.year.astype(int))
)
lifeexp_by_year = (
    panel_lifeexp.groupby("year")[LECol.LIFE_EXPECTANCY]
    .agg(n="count", mean="mean", sd="std")
    .reset_index()
    .assign(se=lambda d: d["sd"] / np.sqrt(d["n"]))
    .assign(ci_low=lambda d: d["mean"] - 1.96 * d["se"])
    .assign(ci_high=lambda d: d["mean"] + 1.96 * d["se"])
)

trend_slope, trend_intercept = np.polyfit(
    lifeexp_by_year["year"].to_numpy(),
    lifeexp_by_year["mean"].to_numpy(),
    deg=1,
)
lifeexp_mean_2000 = float(lifeexp_by_year.query("year == 2000")["mean"].iloc[0])
lifeexp_mean_2015 = float(lifeexp_by_year.query("year == 2015")["mean"].iloc[0])
lifeexp_delta_2000_2015 = lifeexp_mean_2015 - lifeexp_mean_2000

lifeexp_trend_summary = pd.DataFrame(
    {
        "Statistic": [
            "Mean life expectancy (2000)",
            "Mean life expectancy (2015)",
            "Absolute change (2015–2000)",
            "Linear trend (years per decade)",
        ],
        "Value": [
            lifeexp_mean_2000,
            lifeexp_mean_2015,
            lifeexp_delta_2000_2015,
            float(trend_slope) * 10,
        ],
    }
)

# 2014 cross-section (carry-forward predictors; keep residual missingness)
le_xs_2014 = LifeExpectancyDataset.from_csv(
    aggregate_by_country=2014,
    drop_missing_target=True,
    resolve_nand_pred="carry_forward",
)
df_2014 = le_xs_2014.df
df_2014_cc = df_2014.dropna()
pred_cols = le_xs_2014.feature_columns(include_target=False)

# Missingness remaining after carry-forward (2014 cross-section)
rows_with_missing = int(df_2014[pred_cols].isna().any(axis=1).sum())
n_missing_features = int(df_2014[pred_cols].isna().any(axis=0).sum())
cross_section_missing = pd.DataFrame(
    {
        "n_rows": [len(df_2014)],
        "n_complete_cases": [len(df_2014_cc)],
        "n_rows_with_missing": [rows_with_missing],
        "n_missing_features": [n_missing_features],
        "share_missing_pct": [rows_with_missing / len(df_2014) * 100],
    }
)

# Basic dataset coverage
dataset_coverage = pd.DataFrame(
    [
        {
            "view": "Raw panel (no dropping)",
            "n_rows": len(df_panel),
            "n_countries": df_panel[LECol.COUNTRY].nunique(),
            "n_missing_features": panel_missing_features,
            "years": f"{df_panel[LECol.YEAR].dt.year.min()}–{df_panel[LECol.YEAR].dt.year.max()}",
        },
        {
            "view": "2014 cross-section (carry-forward predictors)",
            "n_rows": len(df_2014),
            "n_countries": df_2014.index.nunique(),
            "n_missing_features": n_missing_features,
            "years": "2014",
        },
        {
            "view": "2014 complete-case subset (drop missing predictors)",
            "n_rows": len(df_2014_cc),
            "n_countries": df_2014_cc.index.nunique(),
            "n_missing_features": 0,
            "years": "2014",
        },
    ],
)

# Life expectancy summary stats for the 2014 cross-section
life_expectancy_pretty = le_xs_2014.get_pretty_name(LECol.TARGET)
life_expectancy_stats = (
    df_2014[LECol.TARGET].describe().loc[["count", "mean", "std", "min", "max"]]
)
life_expectancy_stats.index = ["N", "Mean", "SD", "Min", "Max"]
life_expectancy_stats = life_expectancy_stats.to_frame(name=life_expectancy_pretty).T
life_expectancy_stats["N"] = life_expectancy_stats["N"].astype(int)

# Correlation snapshot (2014 complete cases)
corr_result_2014 = (
    le_xs_2014.make_correlation_analyzer(standardized=False, include_target=True)
    .fit()
    .result()
)
corr_result_pred_2014 = (
    le_xs_2014.make_correlation_analyzer(standardized=False, include_target=False)
    .fit()
    .result()
)

target_corr_2014 = corr_result_2014.target_correlations
assert target_corr_2014 is not None


target_corr_2014 = target_corr_2014.assign(
    pretty=lambda d: d.feature.map(le_xs_2014.get_pretty_name),
)

n_show = 5
pos = (
    target_corr_2014.query("correlation > 0")
    .nlargest(n_show, "correlation")
    .assign(
        direction="Positive",
    )
)
neg = (
    target_corr_2014.query("correlation < 0")
    .nsmallest(n_show, "correlation")
    .assign(
        direction="Negative",
    )
)
top_corr_2014 = pd.concat([neg, pos], ignore_index=True).sort_values("correlation")

hotspot_pairs = [
    (LECol.INFANT_DEATHS, LECol.UNDER_FIVE_DEATHS),
    (LECol.GDP, LECol.PERCENTAGE_EXPENDITURE),
    (LECol.THINNESS_5_9_YEARS, LECol.THINNESS_1_19_YEARS),
    (LECol.HDI, LECol.SCHOOLING),
]

corr_pred_matrix = corr_result_pred_2014.matrix
collinearity_hotspots = pd.DataFrame(
    [
        {
            "feature_a": str(feature_a),
            "feature_b": str(feature_b),
            "pretty_pair": f"{le_xs_2014.get_pretty_name(str(feature_a))} vs {le_xs_2014.get_pretty_name(str(feature_b))}",
            "correlation": float(corr_pred_matrix.loc[str(feature_a), str(feature_b)]),
        }
        for feature_a, feature_b in hotspot_pairs
    ],
)


column_glossary = (
    parse_column_docstrings(LECol.__doc__ or "")
    .assign(pretty=lambda d: d.column.map(le_xs_2014.get_pretty_name))
    .assign(transform=lambda d: d.column.map(LECol.transform_label))
)
status_col = LECol.STATUS
column_glossary.loc[
    column_glossary.query("column == @status_col").index,
    "description",
] = "Development status (0 = Developing, 1 = Developed)"

numeric_predictors_2014 = [col for col in pred_cols if col != LECol.STATUS]
numeric_predictors_panel = [col for col in panel_pred_cols if col != LECol.STATUS]

predictor_stats_2014 = (
    df_2014[numeric_predictors_2014]
    .describe()
    .loc[["count", "mean", "std", "min", "max"]]
    .T.rename(
        columns={
            "count": "N",
            "mean": "Mean",
            "std": "SD",
            "min": "Min",
            "max": "Max",
        }
    )
    .rename(index=le_xs_2014.get_pretty_name)
)

predictor_stats_panel = (
    df_panel[numeric_predictors_panel]
    .describe()
    .loc[["count", "mean", "std", "min", "max"]]
    .T.rename(
        columns={
            "count": "N",
            "mean": "Mean",
            "std": "SD",
            "min": "Min",
            "max": "Max",
        }
    )
    .rename(index=le_xs_2014.get_pretty_name)
)

predictor_groups = {
    "Demography & mortality": [
        LECol.ADULT_MORTALITY,
        LECol.INFANT_DEATHS,
        LECol.UNDER_FIVE_DEATHS,
        LECol.HIV_AIDS,
        LECol.POPULATION,
    ],
    "Immunization & infectious disease burden": [
        LECol.HEPATITIS_B,
        LECol.POLIO,
        LECol.DIPHTHERIA,
        LECol.MEASLES,
    ],
    "Socio-economic & investment": [
        LECol.GDP,
        LECol.PERCENTAGE_EXPENDITURE,
        LECol.TOTAL_EXPENDITURE,
        LECol.HDI,
        LECol.SCHOOLING,
        LECol.ALCOHOL,
    ],
    "Nutrition & development status": [
        LECol.BMI,
        LECol.THINNESS_1_19_YEARS,
        LECol.THINNESS_5_9_YEARS,
        LECol.STATUS,
    ],
}

group_pretty = {
    group: [le_xs_2014.get_pretty_name(col) for col in cols if col != LECol.STATUS]
    for group, cols in predictor_groups.items()
}
predictor_stats_2014_by_group = {
    group: predictor_stats_2014.loc[features]
    for group, features in group_pretty.items()
}
predictor_stats_panel_by_group = {
    group: predictor_stats_panel.loc[features]
    for group, features in group_pretty.items()
}
```

# Dataset snapshot

```{python}
# | label: tbl-intro-dataset-coverage
# | tbl-cap: "Dataset coverage summary (raw panel, 2014 cross-section, complete-case subset)."
dataset_coverage.style.hide(axis="index")
```

```{python}
# | label: tbl-intro-cross-section-missing
# | tbl-cap: "Remaining predictor missingness after carry-forward (2014 cross-section)."
cross_section_missing.assign(
    share_missing_pct=lambda d: d["share_missing_pct"].round(1),
).rename(columns={"share_missing_pct": "share_missing_%"}).style.hide(axis="index")
```

Table @tbl-intro-dataset-coverage summarizes the dataset views used downstream, including how many predictors still contain missing values. In the 2014 cross-section, carry-forward imputation retains $n=183$ countries, but 50 (27.3%) still have at least one missing predictor (Table @tbl-intro-cross-section-missing); complete-case analyses therefore use $n=133$. This distinction matters because univariate target plots and development-status comparisons use the larger cross-section, while correlation-based analyses require the complete-case subset. Missing-value handling and robustness checks are documented in [Data Cleaning & Preprocessing](2_preprocessing.qmd) and [Outlier Detection](2_outlier_detection.qmd).

# Life expectancy in the data

We start by characterizing the target variable in the 2014 cross-section and in the longitudinal panel; the development-status split is discussed later in the feature overview.

## 2014 cross-section: distribution

```{python}
# | label: tbl-intro-lifeexp-summary
# | tbl-cap: "Life expectancy summary statistics (2014 cross-section; carry-forward predictors)."
life_expectancy_stats.round(2)
```

```{python}
# | label: fig-intro-lifeexp-dist
# | fig-cap: "Life expectancy distribution in the 2014 cross-section (carry-forward predictors)."
fig, ax = plt.subplots(figsize=(8, 4))
sns.histplot(
    df_2014[LECol.LIFE_EXPECTANCY],
    kde=True,
    ax=ax,
    color="steelblue",
    edgecolor="black",
)
ax.set_xlabel(LECol.LIFE_EXPECTANCY.pretty_name)
ax.set_ylabel("Count")
ax.set_title("Life Expectancy (2014)")
plt.tight_layout()
plt.show()
```

In 2014 ($n=183$), mean life expectancy is 71.5 years (SD 8.6) and ranges from 48.1 to 89.0 (Table @tbl-intro-lifeexp-summary). Figure @fig-intro-lifeexp-dist shows a unimodal distribution with a longer left tail: a small set of countries has markedly shorter life expectancy, while most observations lie between roughly 65 and 80 years. This wide cross-country dispersion motivates multivariate modelling rather than focusing on single predictors in isolation, and it motivates explicit sensitivity checks to extreme observations in [Outlier Detection](2_outlier_detection.qmd).

## Panel trend (2000–2015)

```{python}
# | label: tbl-intro-lifeexp-trend
# | tbl-cap: "Life expectancy trend summary (panel averages; 2000–2015)."
lifeexp_trend_summary.round(2).style.hide(axis="index")
```

```{python}
# | label: fig-intro-lifeexp-time-series
# | fig-cap: "Life expectancy over time in the longitudinal panel (annual mean across countries with 95% CI)."

plot_df = lifeexp_by_year.assign(
    trend=lambda d: trend_intercept + trend_slope * d["year"],
)

fig, ax = plt.subplots(figsize=(9, 4))
ax.plot(plot_df["year"], plot_df["mean"], color="steelblue", label="Annual mean")
ax.fill_between(
    plot_df["year"],
    plot_df["ci_low"],
    plot_df["ci_high"],
    color="steelblue",
    alpha=0.2,
    linewidth=0,
    label="95% CI",
)
ax.plot(
    plot_df["year"],
    plot_df["trend"],
    color="black",
    linestyle="--",
    alpha=0.8,
    label="Linear trend",
)
ax.set_xlabel("Year")
ax.set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)
ax.set_title("Life Expectancy Over Time (2000–2015)")
ax.legend(frameon=False)
plt.tight_layout()
plt.show()
```

Across the full panel, average life expectancy increases from 66.8 years in 2000 to 71.6 years in 2015 (Table @tbl-intro-lifeexp-trend), an absolute change of about 4.9 years. A linear fit to annual means corresponds to an average increase of roughly 0.35 years per year (3.5 per decade). Figure @fig-intro-lifeexp-time-series shows a monotone upward trend in the annual mean; the shaded band is a 95% confidence interval for the annual mean across countries (mean $\pm 1.96 \cdot \mathrm{SE}$). This plot is descriptive: it summarizes cross-country averages by year without modelling within-country trajectories or explicit time effects. For that reason, the main multivariate analyses focus on a single year (2014) to avoid conflating cross-sectional associations with time trends; the year choice is justified in [Year Selection](2_preproc_year_selection.qmd).

# Outcome and predictors

All variables are reported at the country‑year level and come in mixed scales (counts, rates, percentages, and economic magnitudes). The target variable is `life_expectancy` (years). Predictors should be interpreted as country-level proxies rather than causal determinants. They span four conceptual blocks:

1. **Demography & mortality**
   - **Adult Mortality (per 1000):** adult mortality rate per 1,000 population (probability of dying between ages 15 and 60).
   - **Infant Deaths (per 1000):** number of infant deaths per 1,000 population.
   - **Under‑5 Deaths (per 1000):** deaths of children under 5 per 1,000 population.
   - **HIV/AIDS Deaths (per 1000 births):** deaths per 1,000 live births due to HIV/AIDS (ages 0–4).
   - **Population:** total population of the country.

2. **Immunization & infectious disease burden**
   - **Hepatitis B Coverage (%):** HepB immunization coverage among 1‑year‑olds (%).
   - **Polio Coverage (%):** polio immunization coverage among 1‑year‑olds (%).
   - **Diphtheria Coverage (%):** DTP3 immunization coverage among 1‑year‑olds (%).
   - **Measles Cases (per 1000):** number of measles cases per 1,000 population.

3. **Socio‑economic & investment**
   - **GDP per Capita (USD):** gross domestic product per capita (USD).
   - **Health Expenditure (% of GDP per capita):** health spending as a percentage of GDP per capita.
   - **Total Health Expenditure (% of govt expenditure):** government health expenditure as a percentage of total government spending.
   - **Income composition of resources** or **Human Development Index (0–1):** socio‑economic development proxy; see [Investigate HDI](2_investigate_hdi.qmd) for details.
   - **Schooling (years):** average years of schooling.
   - **Alcohol Consumption (liters per capita):** recorded per‑capita (15+) consumption in liters of pure alcohol.

4. **Nutrition & development status**
   - **BMI (Average):** average body‑mass index.
   - **Thinness 10–19 Years (%):** prevalence of thinness among children ages 10–19 (%).
   - **Thinness 5–9 Years (%):** prevalence of thinness among children ages 5–9 (%).
   - **Development Status:** categorical indicator (`0 = Developing`, `1 = Developed`).

For precise definitions and the default transforms used downstream, see the column glossary (Table @tbl-intro-column-glossary).

::: {.callout-note collapse="true"}
## Demography & mortality

```{python}
# | label: tbl-intro-predictor-demography-2014
# | tbl-cap: "Demography & mortality summary statistics (2014 cross-section; numeric features)."
predictor_stats_2014_by_group["Demography & mortality"].round(2).rename_axis("Feature").style
```

```{python}
# | label: tbl-intro-predictor-demography-panel
# | tbl-cap: "Demography & mortality summary statistics (2000–2015 panel; numeric features)."
predictor_stats_panel_by_group["Demography & mortality"].round(2).rename_axis("Feature").style
```

```{python}
# | label: fig-intro-predictor-demography
# | fig-cap: "Demography & mortality: univariate distributions (left) and scatter vs life expectancy (right) for 2014."
group_cols = [col for col in predictor_groups["Demography & mortality"] if col != LECol.STATUS]
n_features = len(group_cols)
fig, axes = plt.subplots(
    n_features,
    2,
    figsize=(12, max(2.2 * n_features, 6)),
    squeeze=False,
)

for i, col in enumerate(group_cols):
    feature_name = le_xs_2014.get_pretty_name(col)
    values = df_2014[col].dropna()
    sns.histplot(values, kde=True, ax=axes[i, 0], color="steelblue", edgecolor="black")
    axes[i, 0].set_ylabel(feature_name)
    axes[i, 0].set_xlabel("")

    plot_df = df_2014[[col, LECol.LIFE_EXPECTANCY]].dropna()
    sns.scatterplot(
        data=plot_df,
        x=col,
        y=LECol.LIFE_EXPECTANCY,
        ax=axes[i, 1],
        s=12,
        alpha=0.5,
        color="steelblue",
    )
    axes[i, 1].set_xlabel(feature_name)
    axes[i, 1].set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)

plt.tight_layout()
plt.show()
```
:::

::: {.callout-note collapse="true"}
## Immunization & infectious disease burden

```{python}
# | label: tbl-intro-predictor-immunization-2014
# | tbl-cap: "Immunization & infectious disease summary statistics (2014 cross-section; numeric features)."
predictor_stats_2014_by_group["Immunization & infectious disease burden"].round(2).rename_axis("Feature").style
```

```{python}
# | label: tbl-intro-predictor-immunization-panel
# | tbl-cap: "Immunization & infectious disease summary statistics (2000–2015 panel; numeric features)."
predictor_stats_panel_by_group["Immunization & infectious disease burden"].round(2).rename_axis("Feature").style
```

```{python}
# | label: fig-intro-predictor-immunization
# | fig-cap: "Immunization & infectious disease: univariate distributions (left) and scatter vs life expectancy (right) for 2014."
group_cols = [col for col in predictor_groups["Immunization & infectious disease burden"] if col != LECol.STATUS]
n_features = len(group_cols)
fig, axes = plt.subplots(
    n_features,
    2,
    figsize=(12, max(2.2 * n_features, 6)),
    squeeze=False,
)

for i, col in enumerate(group_cols):
    feature_name = le_xs_2014.get_pretty_name(col)
    values = df_2014[col].dropna()
    sns.histplot(values, kde=True, ax=axes[i, 0], color="steelblue", edgecolor="black")
    axes[i, 0].set_ylabel(feature_name)
    axes[i, 0].set_xlabel("")

    plot_df = df_2014[[col, LECol.LIFE_EXPECTANCY]].dropna()
    sns.scatterplot(
        data=plot_df,
        x=col,
        y=LECol.LIFE_EXPECTANCY,
        ax=axes[i, 1],
        s=12,
        alpha=0.5,
        color="steelblue",
    )
    axes[i, 1].set_xlabel(feature_name)
    axes[i, 1].set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)

plt.tight_layout()
plt.show()
```
:::

::: {.callout-note collapse="true"}
## Socio-economic & investment

```{python}
# | label: tbl-intro-predictor-socioecon-2014
# | tbl-cap: "Socio-economic & investment summary statistics (2014 cross-section; numeric features)."
predictor_stats_2014_by_group["Socio-economic & investment"].round(2).rename_axis("Feature").style
```

```{python}
# | label: tbl-intro-predictor-socioecon-panel
# | tbl-cap: "Socio-economic & investment summary statistics (2000–2015 panel; numeric features)."
predictor_stats_panel_by_group["Socio-economic & investment"].round(2).rename_axis("Feature").style
```

```{python}
# | label: fig-intro-predictor-socioecon
# | fig-cap: "Socio-economic & investment: univariate distributions (left) and scatter vs life expectancy (right) for 2014."
group_cols = [col for col in predictor_groups["Socio-economic & investment"] if col != LECol.STATUS]
n_features = len(group_cols)
fig, axes = plt.subplots(
    n_features,
    2,
    figsize=(12, max(2.2 * n_features, 6)),
    squeeze=False,
)

for i, col in enumerate(group_cols):
    feature_name = le_xs_2014.get_pretty_name(col)
    values = df_2014[col].dropna()
    sns.histplot(values, kde=True, ax=axes[i, 0], color="steelblue", edgecolor="black")
    axes[i, 0].set_ylabel(feature_name)
    axes[i, 0].set_xlabel("")

    plot_df = df_2014[[col, LECol.LIFE_EXPECTANCY]].dropna()
    sns.scatterplot(
        data=plot_df,
        x=col,
        y=LECol.LIFE_EXPECTANCY,
        ax=axes[i, 1],
        s=12,
        alpha=0.5,
        color="steelblue",
    )
    axes[i, 1].set_xlabel(feature_name)
    axes[i, 1].set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)

plt.tight_layout()
plt.show()
```
:::

::: {.callout-note collapse="true"}
## Nutrition & development status

```{python}
# | label: tbl-intro-predictor-nutrition-2014
# | tbl-cap: "Nutrition summary statistics (2014 cross-section; numeric features)."
predictor_stats_2014_by_group["Nutrition & development status"].round(2).rename_axis("Feature").style
```

```{python}
# | label: tbl-intro-predictor-nutrition-panel
# | tbl-cap: "Nutrition summary statistics (2000–2015 panel; numeric features)."
predictor_stats_panel_by_group["Nutrition & development status"].round(2).rename_axis("Feature").style
```

```{python}
# | label: fig-intro-predictor-nutrition
# | fig-cap: "Nutrition: univariate distributions (left) and scatter vs life expectancy (right) for 2014."
group_cols = [col for col in predictor_groups["Nutrition & development status"] if col != LECol.STATUS]
n_features = len(group_cols)
fig, axes = plt.subplots(
    n_features,
    2,
    figsize=(12, max(2.2 * n_features, 6)),
    squeeze=False,
)

for i, col in enumerate(group_cols):
    feature_name = le_xs_2014.get_pretty_name(col)
    values = df_2014[col].dropna()
    sns.histplot(values, kde=True, ax=axes[i, 0], color="steelblue", edgecolor="black")
    axes[i, 0].set_ylabel(feature_name)
    axes[i, 0].set_xlabel("")

    plot_df = df_2014[[col, LECol.LIFE_EXPECTANCY]].dropna()
    sns.scatterplot(
        data=plot_df,
        x=col,
        y=LECol.LIFE_EXPECTANCY,
        ax=axes[i, 1],
        s=12,
        alpha=0.5,
        color="steelblue",
    )
    axes[i, 1].set_xlabel(feature_name)
    axes[i, 1].set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)

plt.tight_layout()
plt.show()
```

```{python}
# | label: fig-intro-status-gap
# | fig-cap: "Life expectancy by development status (2014 cross-section; carry-forward predictors)."
plot_df = df_2014.assign(
    status_label=lambda d: d[LECol.STATUS].map({0: "Developing", 1: "Developed"}),
)

order = ["Developing", "Developed"]
status_stats = (
    plot_df.groupby("status_label", observed=True)[LECol.LIFE_EXPECTANCY]
    .agg(n="count", mean="mean", std="std", median="median", max="max")
    .reindex(order)
)

fig, ax = plt.subplots(figsize=(7, 4))
sns.boxplot(
    data=plot_df,
    x="status_label",
    y=LECol.LIFE_EXPECTANCY,
    ax=ax,
    color="lightgray",
    order=order,
)
sns.stripplot(
    data=plot_df,
    x="status_label",
    y=LECol.LIFE_EXPECTANCY,
    ax=ax,
    color="steelblue",
    alpha=0.6,
    jitter=True,
    size=4,
    order=order,
)
ax.set_xlabel("")
ax.set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)
ax.set_title("Development Status Gap")

plt.tight_layout()
plt.show()
```

```{python}
# | label: tbl-intro-status-stats
# | tbl-cap: "Life expectancy by development status (2014 cross-section; carry-forward predictors)."
status_stats.loc[:, ["n", "mean", "std", "median"]].rename_axis("Status").style.format(
    {"mean": "{:.2f}", "std": "{:.2f}", "median": "{:.2f}"}
)
```

Developed countries have markedly higher life expectancy in 2014: the mean is 81.1 years (SD 4.2, $n=32$) versus 69.5 years (SD 7.8, $n=151$) for developing countries (Table @tbl-intro-status-stats), a difference of about 11.6 years. Figure @fig-intro-status-gap shows substantial heterogeneity among developing countries and a tighter distribution among developed countries; the upper tail of developing countries overlaps with the lower tail of developed countries. We use development status as a stratifying variable in descriptives and as a baseline covariate (and potential effect modifier) in [Regression](5_regression.qmd), and we examine multivariate country profiles beyond this binary split in [Clustering](4_clustering.qmd).
:::

# Predictors and modelling considerations

The predictor set above is heterogeneous in scale and distribution. To improve comparability across variables and reduce the influence of heavy tails, most multivariate chapters use the transformed and standardized view produced by `LifeExpectancyDataset.tf_and_norm()` (see [Data Cleaning & Preprocessing](2_preprocessing.qmd)).

Three modelling issues shape the rest of the report. First, residual missingness after carry-forward reduces the effective sample size for complete-case analyses (Table @tbl-intro-dataset-coverage), and we document sensitivity to missing-data handling in [Data Cleaning & Preprocessing](2_preprocessing.qmd). Second, many predictors are strongly correlated, so multicollinearity is addressed explicitly through correlation analysis and PCA-based grouping ([Correlation Analysis](3_correlation.qmd), [Principal Component Analysis](3_pca.qmd)) before interpreting multivariate regression coefficients and before running selection procedures ([Model Selection](6_model_selection.qmd), [Regression](5_regression.qmd)). Third, the dataset’s HDI-like feature is mechanically related to life expectancy by construction; we therefore validate its interpretation against UNDP data in [Investigate HDI](2_investigate_hdi.qmd) and treat it cautiously in downstream models.

## Correlation snapshot (2014 complete-case subset)

To motivate the multivariate steps, we report a brief set of bivariate Pearson correlations computed on the 2014 complete-case subset ($n=133$). These correlations summarize *linear* association and do not adjust for confounding; the full correlation structure (incl. transform sensitivity and feature grouping) is analyzed in [Correlation Analysis](3_correlation.qmd).

::: {.callout-note collapse="true"}
## ama-tlbx usage pattern (correlation analyzer)

```{python}
# | label: code-intro-corr-usage
# | echo: true
# | eval: false
corr_result = (
    le_xs_2014.make_correlation_analyzer(standardized=False, include_target=True)
    .fit()
    .result()
)
```
:::

```{python}
# | label: fig-intro-top-corr
# | fig-cap: "Strongest positive and negative bivariate correlations with life expectancy (2014 complete-case subset)."
fig, ax = plt.subplots(figsize=(8, 5))
sns.barplot(
    data=top_corr_2014,
    x="correlation",
    y="pretty",
    hue="direction",
    order=top_corr_2014.sort_values("correlation")["pretty"].tolist(),
    dodge=False,
    palette="coolwarm",
    ax=ax,
)
ax.axvline(0, color="black", linewidth=1)
ax.set_xlabel(f"Pearson correlation with {LECol.LIFE_EXPECTANCY.pretty_name} ($r$)")
ax.set_ylabel("")
ax.set_title("Strongest Linear Associations")
ax.legend(title="")
plt.tight_layout()
plt.show()
```

```{python}
# | label: tbl-intro-top-corr
# | tbl-cap: "Top 5 positive and negative correlations with life expectancy (2014 complete-case subset)."
top_corr_2014.assign(r=lambda d: d.correlation.round(2)).loc[:, ["pretty", "r"]].rename(
    columns={"pretty": "Feature", "r": "Correlation (r)"},
).style.hide(axis="index")
```

```{python}
# | label: tbl-intro-collinearity-hotspots
# | tbl-cap: "Selected multicollinearity hotspots (pairwise Pearson correlations; 2014 complete-case subset)."
collinearity_hotspots.assign(r=lambda d: d.correlation.round(3)).loc[
    :, ["pretty_pair", "r"]
].rename(
    columns={"pretty_pair": "Pair", "r": "Correlation (r)"},
).style.hide(axis="index")
```

The feature–target correlations quantify a strong development gradient in 2014 (Table @tbl-intro-top-corr). The strongest positive associations are with HDI ($r \approx 0.89$) and schooling ($r \approx 0.79$), while the strongest negative associations are with adult mortality ($r \approx -0.77$) and HIV/AIDS deaths ($r \approx -0.61$). Several variables that plausibly reflect development level (development status, BMI, alcohol consumption) are also positively correlated with life expectancy; these are descriptive patterns and can reflect confounding by broader socio-economic conditions rather than direct effects. In multivariate modelling we therefore focus on conditional associations, compare competing specifications, and assess out-of-sample performance ([Model Selection](6_model_selection.qmd), [Regression](5_regression.qmd)).

The hotspot pairs in Table @tbl-intro-collinearity-hotspots show that some predictors are close to redundant measurements (e.g., infant vs under-5 deaths, $r \approx 0.995$; thinness 5–9 vs 10–19, $r \approx 0.94$; GDP vs percentage expenditure, $r \approx 0.95$). This motivates explicit redundancy handling (feature grouping and PCA blocks) before interpreting coefficients and conducting selection ([Correlation Analysis](3_correlation.qmd), [Principal Component Analysis](3_pca.qmd)). Finally, because HDI includes life expectancy by construction, its bivariate correlation is partly mechanical; we therefore treat it primarily as a descriptive proxy and assess sensitivity in [Investigate HDI](2_investigate_hdi.qmd).


::: {.callout-note collapse="true"}
## Column glossary (from `LECol` metadata)

The table below summarizes column meanings and the default transforms applied later in the pipeline (`tf_and_norm`).

```{python}
# | label: tbl-intro-column-glossary
# | tbl-cap: "Column definitions and default preprocessing transforms."
column_glossary.loc[:, ["pretty", "description", "transform"]].rename(
    columns={
        "pretty": "Feature",
        "description": "Definition (units / scale)",
        "transform": "Default transform",
    },
).style.hide(axis="index")

```
:::

Taken together, the introduction suggests a dominant development-related gradient in life expectancy (large cross-country dispersion, a clear developed–developing gap, and strong bivariate associations with schooling/HDI proxies), while also highlighting practical constraints for multivariate inference: missing predictors reduce effective sample size, and strong collinearity requires redundancy handling before coefficient interpretation. The next chapters address these issues in sequence—first establishing the analysis year and preprocessing choices, then characterizing redundancy via correlations/PCA and multivariate profiles via clustering, and finally fitting, selecting, and validating regression models on a year-based holdout.

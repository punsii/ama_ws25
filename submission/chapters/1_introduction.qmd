---
title: "Introduction"
format:
  html:
    toc: true
---

We analyze the WHO [“Life Expectancy (WHO)” dataset](https://www.kaggle.com/datasets/kumarajarshi/life-expectancy-who), published on Kaggle [@KumarRajarshi]. It is a country-year panel (193 countries, 2000–2015) with the target variable `life_expectancy` (years) and 20 candidate predictors spanning mortality burden, immunization, socio-economic development, and nutrition.

Our main goal is **explanatory and predictive regression**: (i) identify which predictors are most strongly associated with life expectancy (direction and magnitude), and (ii) quantify predictive performance out-of-sample. To reduce within-country temporal dependence, most multivariate analyses use a single cross-section (2014; see [Year Selection](2_preproc_year_selection.qmd)); regression models are evaluated on a separate holdout year in [Regression](5_regression.qmd). All findings are interpreted as descriptive associations in observational data (not causal effects).

# Research questions and chapter map

The report follows the course workflow (preprocessing → descriptives → exploration → regression). This introduction summarizes the analysis views and a small set of descriptive and bivariate patterns that motivate the later chapters. Concretely:

1. **Choose a representative cross-section** and justify the 2014 framing ([Year Selection](2_preproc_year_selection.qmd)).
2. **Clean and transform the data**, documenting missingness and outlier sensitivity ([Data Cleaning & Preprocessing](2_preprocessing.qmd), [Outlier Detection](2_outlier_detection.qmd)).
3. **Quantify redundancy and low-dimensional structure** via correlations and grouped PCA ([Correlation Analysis](3_correlation.qmd), [Principal Component Analysis](3_pca.qmd)).
4. **Explore country profiles** in standardized feature space ([Clustering](4_clustering.qmd)).
5. **Select parsimonious models** using transparent criteria and search strategies ([Model Selection](6_model_selection.qmd)).
6. **Fit and diagnose OLS models** and evaluate generalization to a holdout year ([Regression](5_regression.qmd)).
7. **Document limitations and open questions** for follow-up ([Open Questions](5_open_questions.qmd)).
```{python}
# | label: intro-setup
# | include: false
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from ama_tlbx.data import LECol, LifeExpectancyDataset
from ama_tlbx.utils.plotting_config import DEFAULT_PLOT_CFG

np.random.seed(42)
DEFAULT_PLOT_CFG.apply_global()

# Raw longitudinal panel
le_panel = LifeExpectancyDataset.from_csv(
    aggregate_by_country=False,
    drop_missing_target=False,
    resolve_nand_pred=False,
)
df_panel = le_panel.df

# Life expectancy time series (panel; mean across countries with 95% CI)
panel_lifeexp = (
    df_panel[[LECol.YEAR, LECol.LIFE_EXPECTANCY]]
    .dropna(subset=[LECol.LIFE_EXPECTANCY])
    .assign(year=lambda d: d[LECol.YEAR].dt.year.astype(int))
)
lifeexp_by_year = (
    panel_lifeexp.groupby("year")[LECol.LIFE_EXPECTANCY]
    .agg(n="count", mean="mean", sd="std")
    .reset_index()
    .assign(se=lambda d: d["sd"] / np.sqrt(d["n"]))
    .assign(ci_low=lambda d: d["mean"] - 1.96 * d["se"])
    .assign(ci_high=lambda d: d["mean"] + 1.96 * d["se"])
)

trend_slope, trend_intercept = np.polyfit(
    lifeexp_by_year["year"].to_numpy(),
    lifeexp_by_year["mean"].to_numpy(),
    deg=1,
)
lifeexp_mean_2000 = float(
    lifeexp_by_year.loc[lifeexp_by_year["year"] == 2000, "mean"].iloc[0]
)
lifeexp_mean_2015 = float(
    lifeexp_by_year.loc[lifeexp_by_year["year"] == 2015, "mean"].iloc[0]
)
lifeexp_delta_2000_2015 = lifeexp_mean_2015 - lifeexp_mean_2000

lifeexp_trend_summary = pd.DataFrame(
    {
        "Statistic": [
            "Mean life expectancy (2000)",
            "Mean life expectancy (2015)",
            "Absolute change (2015–2000)",
            "Linear trend (years per year)",
            "Linear trend (years per decade)",
        ],
        "Value": [
            lifeexp_mean_2000,
            lifeexp_mean_2015,
            lifeexp_delta_2000_2015,
            float(trend_slope),
            float(trend_slope) * 10,
        ],
    }
)

# 2014 cross-section (carry-forward predictors; keep residual missingness)
le_xs_2014 = LifeExpectancyDataset.from_csv(
    aggregate_by_country=2014,
    drop_missing_target=True,
    resolve_nand_pred="carry_forward",
)
df_2014 = le_xs_2014.df
df_2014_cc = df_2014.dropna()
pred_cols = le_xs_2014.feature_columns(include_target=False)

# Basic dataset coverage
dataset_coverage = pd.DataFrame(
    [
        {
            "view": "Raw panel (no dropping)",
            "n_rows": len(df_panel),
            "n_countries": df_panel[LECol.COUNTRY].nunique(),
            "years": f"{df_panel[LECol.YEAR].dt.year.min()}–{df_panel[LECol.YEAR].dt.year.max()}",
        },
        {
            "view": "2014 cross-section (carry-forward predictors)",
            "n_rows": len(df_2014),
            "n_countries": df_2014.index.nunique(),
            "years": "2014",
        },
        {
            "view": "2014 complete-case subset (drop missing predictors)",
            "n_rows": len(df_2014_cc),
            "n_countries": df_2014_cc.index.nunique(),
            "years": "2014",
        },
    ],
)

# Missingness remaining after carry-forward (2014 cross-section)
rows_with_missing = int(df_2014[pred_cols].isna().any(axis=1).sum())
n_missing_features = int(df_2014[pred_cols].isna().any(axis=0).sum())
cross_section_missing = pd.DataFrame(
    {
        "n_rows": [len(df_2014)],
        "n_complete_cases": [len(df_2014_cc)],
        "n_rows_with_missing": [rows_with_missing],
        "n_missing_features": [n_missing_features],
        "share_missing_pct": [rows_with_missing / len(df_2014) * 100],
    }
)

# Life expectancy summary stats for the 2014 cross-section
life_expectancy_pretty = le_xs_2014.get_pretty_name(str(LECol.TARGET))
life_expectancy_stats = (
    df_2014[LECol.TARGET].describe().loc[["count", "mean", "std", "min", "max"]]
)
life_expectancy_stats.index = ["N", "Mean", "SD", "Min", "Max"]
life_expectancy_stats = life_expectancy_stats.to_frame(name=life_expectancy_pretty).T
life_expectancy_stats["N"] = life_expectancy_stats["N"].astype(int)

# Correlation snapshot (2014 complete cases)
corr_result_2014 = (
    le_xs_2014.make_correlation_analyzer(standardized=False, include_target=True)
    .fit()
    .result()
)
corr_result_pred_2014 = (
    le_xs_2014.make_correlation_analyzer(standardized=False, include_target=False)
    .fit()
    .result()
)

target_corr_2014 = corr_result_2014.target_correlations
assert target_corr_2014 is not None

target_corr_2014 = target_corr_2014.assign(
    pretty=lambda d: d.feature.map(le_xs_2014.get_pretty_name),
)

n_show = 5
pos = target_corr_2014.query("correlation > 0").nlargest(n_show, "correlation").assign(
    direction="Positive",
)
neg = target_corr_2014.query("correlation < 0").nsmallest(n_show, "correlation").assign(
    direction="Negative",
)
top_corr_2014 = pd.concat([neg, pos], ignore_index=True).sort_values("correlation")

hotspot_pairs = [
    (LECol.INFANT_DEATHS, LECol.UNDER_FIVE_DEATHS),
    (LECol.GDP, LECol.PERCENTAGE_EXPENDITURE),
    (LECol.THINNESS_5_9_YEARS, LECol.THINNESS_1_19_YEARS),
    (LECol.HDI, LECol.SCHOOLING),
]

corr_pred_matrix = corr_result_pred_2014.matrix
collinearity_hotspots = pd.DataFrame(
    [
        {
            "feature_a": str(feature_a),
            "feature_b": str(feature_b),
            "pretty_pair": f"{le_xs_2014.get_pretty_name(str(feature_a))} vs {le_xs_2014.get_pretty_name(str(feature_b))}",
            "correlation": float(corr_pred_matrix.loc[str(feature_a), str(feature_b)]),
        }
        for feature_a, feature_b in hotspot_pairs
    ],
)


# Helper: map per-column transforms to readable labels for the report
def _transform_label(feature: str) -> str:
    try:
        col = LECol(feature)
    except ValueError:
        return "custom"

    transform = col.metadata().transform
    if transform is None:
        return "none"

    name = getattr(transform, "__name__", "custom")
    if name == "_log1p_under_coverage":
        return "log1p(100 - x)"
    if name == "log1p":
        return "log1p(x)"
    if name == "_status_dummies":
        return "dummy (developed=1)"
    return name


def _parse_column_docstrings(doc: str) -> pd.DataFrame:
    rows: list[dict[str, str]] = []
    for raw_line in (doc or "").splitlines():
        line = raw_line.strip()
        if not line.startswith("- ``") or " - " not in line:
            continue
        left, desc = line.split(" - ", 1)
        name_part, dtype_part = left.split(": ", 1)
        name = name_part.replace("- ``", "").replace("``", "").strip()
        rows.append(
            {"column": name, "type": dtype_part.strip(), "description": desc.strip()}
        )
    return pd.DataFrame(rows)


column_glossary = (
    _parse_column_docstrings(LECol.__doc__ or "")
    .assign(pretty=lambda d: d.column.map(le_xs_2014.get_pretty_name))
    .assign(transform=lambda d: d.column.map(_transform_label))
)
column_glossary.loc[column_glossary["column"] == str(LECol.STATUS), "description"] = (
    "Development status (0 = Developing, 1 = Developed)"
)
```

# Dataset snapshot

```{python}
# | label: tbl-intro-dataset-coverage
# | tbl-cap: "Dataset coverage summary (raw panel, 2014 cross-section, complete-case subset)."
dataset_coverage.style.hide(axis="index")
```

Table @tbl-intro-dataset-coverage summarizes the dataset views used downstream. In the 2014 cross-section, carry-forward imputation retains $n=183$ countries, but 50 (27.3%) still have at least one missing predictor; complete-case analyses therefore use $n=133$. This distinction matters because univariate target plots and development-status comparisons use the larger cross-section, while correlation-based analyses require the complete-case subset. Missing-value handling and robustness checks are documented in [Data Cleaning & Preprocessing](2_preprocessing.qmd) and [Outlier Detection](2_outlier_detection.qmd).

# Life expectancy in the data

We start by characterizing the target variable at three levels: the 2014 cross-sectional distribution, differences by development status, and the longitudinal trend in annual cross-country averages.

## 2014 cross-section: distribution

```{python}
# | label: tbl-intro-lifeexp-summary
# | tbl-cap: "Life expectancy summary statistics (2014 cross-section; carry-forward predictors)."
life_expectancy_stats.round(2)
```

```{python}
# | label: fig-intro-lifeexp-dist
# | fig-cap: "Life expectancy distribution in the 2014 cross-section (carry-forward predictors)."
fig, ax = plt.subplots(figsize=(8, 4))
sns.histplot(
    df_2014[LECol.LIFE_EXPECTANCY],
    kde=True,
    ax=ax,
    color="steelblue",
    edgecolor="black",
)
ax.set_xlabel(LECol.LIFE_EXPECTANCY.pretty_name)
ax.set_ylabel("Count")
ax.set_title("Life Expectancy (2014)")
plt.tight_layout()
plt.show()
```

In 2014 ($n=183$), mean life expectancy is 71.5 years (SD 8.6) and ranges from 48.1 to 89.0 (Table @tbl-intro-lifeexp-summary). Figure @fig-intro-lifeexp-dist shows a unimodal distribution with a longer left tail: a small set of countries has markedly shorter life expectancy, while most observations lie between roughly 65 and 80 years. This wide cross-country dispersion motivates multivariate modelling rather than focusing on single predictors in isolation.

## 2014 cross-section: development status gap

```{python}
# | label: fig-intro-status-gap
# | fig-cap: "Life expectancy by development status (2014 cross-section; carry-forward predictors)."
plot_df = df_2014.assign(
    status_label=lambda d: d[LECol.STATUS].map({0: "Developing", 1: "Developed"}),
)

order = ["Developing", "Developed"]
status_stats = (
    plot_df.groupby("status_label", observed=True)[LECol.LIFE_EXPECTANCY]
    .agg(n="count", mean="mean", std="std", median="median", max="max")
    .reindex(order)
)

fig, ax = plt.subplots(figsize=(7, 4))
sns.boxplot(
    data=plot_df,
    x="status_label",
    y=LECol.LIFE_EXPECTANCY,
    ax=ax,
    color="lightgray",
    order=order,
)
sns.stripplot(
    data=plot_df,
    x="status_label",
    y=LECol.LIFE_EXPECTANCY,
    ax=ax,
    color="steelblue",
    alpha=0.6,
    jitter=True,
    size=4,
    order=order,
)
ax.set_xlabel("")
ax.set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)
ax.set_title("Development Status Gap")

ymin, ymax = ax.get_ylim()
offset = 0.03 * (ymax - ymin)
for i, label in enumerate(order):
    mean = status_stats.loc[label, "mean"]
    std = status_stats.loc[label, "std"]
    y = status_stats.loc[label, "max"] + offset
    ax.text(
        i,
        y,
        f"mean={mean:.2f}\nstd={std:.2f}",
        ha="center",
        va="bottom",
        fontsize=9,
        color="black",
    )

plt.tight_layout()
plt.show()

```

```{python}
# | label: tbl-intro-status-stats
# | tbl-cap: "Life expectancy by development status (2014 cross-section; carry-forward predictors)."
status_stats.loc[:, ["n", "mean", "std", "median"]].rename_axis("Status").style.format(
    {"mean": "{:.2f}", "std": "{:.2f}", "median": "{:.2f}"}
)
```

Developed countries have markedly higher life expectancy in 2014: the mean is 81.1 years (SD 4.2, $n=32$) versus 69.5 years (SD 7.8, $n=151$) for developing countries (Table @tbl-intro-status-stats), a difference of about 11.6 years. Figure @fig-intro-status-gap shows substantial heterogeneity among developing countries and a tighter distribution among developed countries; the upper tail of developing countries overlaps with the lower tail of developed countries. We use development status as a stratifying variable in descriptives and as a baseline covariate (and potential effect modifier) in [Regression](5_regression.qmd).

## Panel trend (2000–2015)

```{python}
# | label: tbl-intro-lifeexp-trend
# | tbl-cap: "Life expectancy trend summary (panel averages; 2000–2015)."
lifeexp_trend_summary.style.hide(axis="index").format({"Value": "{:.2f}"})
```

```{python}
# | label: fig-intro-lifeexp-time-series
# | fig-cap: "Life expectancy over time in the longitudinal panel (annual mean across countries with 95% CI)."

plot_df = lifeexp_by_year.assign(
    trend=lambda d: trend_intercept + trend_slope * d["year"],
)

fig, ax = plt.subplots(figsize=(9, 4))
ax.plot(plot_df["year"], plot_df["mean"], color="steelblue", label="Annual mean")
ax.fill_between(
    plot_df["year"],
    plot_df["ci_low"],
    plot_df["ci_high"],
    color="steelblue",
    alpha=0.2,
    linewidth=0,
    label="95% CI",
)
ax.plot(
    plot_df["year"],
    plot_df["trend"],
    color="black",
    linestyle="--",
    alpha=0.8,
    label="Linear trend",
)
ax.set_xlabel("Year")
ax.set_ylabel(LECol.LIFE_EXPECTANCY.pretty_name)
ax.set_title("Life Expectancy Over Time (2000–2015)")
ax.legend(frameon=False)
plt.tight_layout()
plt.show()
```

Across the full panel, average life expectancy increases from 66.8 years in 2000 to 71.6 years in 2015 (Table @tbl-intro-lifeexp-trend), an absolute change of about 4.9 years. A linear fit to annual means corresponds to an average increase of roughly 0.35 years per year (3.5 per decade). Figure @fig-intro-lifeexp-time-series shows a monotone upward trend in the annual mean; the shaded band is a 95% confidence interval for the annual mean across countries (mean $\pm 1.96 \cdot \mathrm{SE}$). This plot is descriptive: it summarizes cross-country averages by year without modelling within-country trajectories or explicit time effects. The 2014 cross-section used in most multivariate chapters is chosen to balance recency and data completeness (see [Year Selection](2_preproc_year_selection.qmd)).

# Outcome and predictors

All variables are reported at the country‑year level and come in mixed scales (counts, rates, percentages, and economic magnitudes). The target variable is `life_expectancy` (years). Predictors span four conceptual blocks:

1. **Demography & mortality**
   - **Adult Mortality (per 1000):** adult mortality rate per 1,000 population (probability of dying between ages 15 and 60).
   - **Infant Deaths (per 1000):** number of infant deaths per 1,000 population.
   - **Under‑5 Deaths (per 1000):** deaths of children under 5 per 1,000 population.
   - **HIV/AIDS Deaths (per 1000 births):** deaths per 1,000 live births due to HIV/AIDS (ages 0–4).
   - **Population:** total population of the country.

2. **Immunization & infectious disease burden**
   - **Hepatitis B Coverage (%):** HepB immunization coverage among 1‑year‑olds (%).
   - **Polio Coverage (%):** polio immunization coverage among 1‑year‑olds (%).
   - **Diphtheria Coverage (%):** DTP3 immunization coverage among 1‑year‑olds (%).
   - **Measles Cases (per 1000):** number of measles cases per 1,000 population.

3. **Socio‑economic & investment**
   - **GDP per Capita (USD):** gross domestic product per capita (USD).
   - **Health Expenditure (% of GDP per capita):** health spending as a percentage of GDP per capita.
   - **Total Health Expenditure (% of govt expenditure):** government health expenditure as a percentage of total government spending.
   - **Income composition of resources** or **Human Development Index (0–1):** socio‑economic development proxy; see [Investigate HDI](2_investigate_hdi.qmd) for details.
   - **Schooling (years):** average years of schooling.
   - **Alcohol Consumption (liters per capita):** recorded per‑capita (15+) consumption in liters of pure alcohol.

4. **Nutrition & development status**
   - **BMI (Average):** average body‑mass index.
   - **Thinness 10–19 Years (%):** prevalence of thinness among children ages 10–19 (%).
   - **Thinness 5–9 Years (%):** prevalence of thinness among children ages 5–9 (%).
   - **Development Status:** categorical indicator (`0 = Developing`, `1 = Developed`).

For precise definitions and the default transforms used downstream, see the column glossary (Table @tbl-intro-column-glossary).

# Predictors and modelling considerations

The predictor set above is heterogeneous in scale and distribution. To improve comparability across variables and reduce the influence of heavy tails, most multivariate chapters use the transformed and standardized view produced by `LifeExpectancyDataset.tf_and_norm()` (see [Data Cleaning & Preprocessing](2_preprocessing.qmd)).

Three modelling issues shape the rest of the report. First, residual missingness after carry-forward reduces the effective sample size for complete-case analyses (Table @tbl-intro-dataset-coverage), and we document sensitivity to missing-data handling in [Data Cleaning & Preprocessing](2_preprocessing.qmd). Second, many predictors are strongly correlated, so multicollinearity is addressed explicitly through correlation analysis and PCA-based grouping ([Correlation Analysis](3_correlation.qmd), [Principal Component Analysis](3_pca.qmd)) before interpreting multivariate regression coefficients and before running selection procedures ([Model Selection](6_model_selection.qmd), [Regression](5_regression.qmd)). Third, the dataset’s HDI-like feature is mechanically related to life expectancy by construction; we therefore validate its interpretation against UNDP data in [Investigate HDI](2_investigate_hdi.qmd) and treat it cautiously in downstream models.

## Correlation snapshot (2014 complete-case subset)

To motivate the multivariate steps, we report a brief set of bivariate Pearson correlations computed on the 2014 complete-case subset ($n=133$). These correlations summarize *linear* association and do not adjust for confounding; the full correlation structure (incl. transform sensitivity and feature grouping) is analyzed in [Correlation Analysis](3_correlation.qmd).

```{python}
# | label: fig-intro-top-corr
# | fig-cap: "Strongest positive and negative bivariate correlations with life expectancy (2014 complete-case subset)."
fig, ax = plt.subplots(figsize=(8, 5))
sns.barplot(
    data=top_corr_2014,
    x="correlation",
    y="pretty",
    hue="direction",
    order=top_corr_2014.sort_values("correlation")["pretty"].tolist(),
    dodge=False,
    palette="coolwarm",
    ax=ax,
)
ax.axvline(0, color="black", linewidth=1)
ax.set_xlabel(f"Pearson correlation with {LECol.LIFE_EXPECTANCY.pretty_name} ($r$)")
ax.set_ylabel("")
ax.set_title("Strongest Linear Associations")
ax.legend(title="")
plt.tight_layout()
plt.show()
```

```{python}
# | label: tbl-intro-top-corr
# | tbl-cap: "Top 5 positive and negative correlations with life expectancy (2014 complete-case subset)."
top_corr_2014.assign(r=lambda d: d.correlation.round(2)).loc[:, ["pretty", "r"]].rename(
    columns={"pretty": "Feature", "r": "Correlation (r)"},
).style.hide(axis="index")
```

```{python}
# | label: tbl-intro-collinearity-hotspots
# | tbl-cap: "Selected multicollinearity hotspots (pairwise Pearson correlations; 2014 complete-case subset)."
collinearity_hotspots.assign(r=lambda d: d.correlation.round(3)).loc[
    :, ["pretty_pair", "r"]
].rename(
    columns={"pretty_pair": "Pair", "r": "Correlation (r)"},
).style.hide(axis="index")
```

The feature–target correlations quantify a strong development gradient in 2014 (Table @tbl-intro-top-corr). The strongest positive associations are with HDI ($r \approx 0.89$) and schooling ($r \approx 0.79$), while the strongest negative associations are with adult mortality ($r \approx -0.77$) and HIV/AIDS deaths ($r \approx -0.61$). Several variables that plausibly reflect development level (development status, BMI, alcohol consumption) are also positively correlated with life expectancy; these are descriptive patterns and can reflect confounding by broader socio-economic conditions rather than direct effects. In multivariate modelling we therefore focus on conditional associations, compare competing specifications, and assess out-of-sample performance ([Model Selection](6_model_selection.qmd), [Regression](5_regression.qmd)).

The hotspot pairs in Table @tbl-intro-collinearity-hotspots show that some predictors are close to redundant measurements (e.g., infant vs under-5 deaths, $r \approx 0.995$; thinness 5–9 vs 10–19, $r \approx 0.94$; GDP vs percentage expenditure, $r \approx 0.95$). This motivates explicit redundancy handling (feature grouping and PCA blocks) before interpreting coefficients and conducting selection ([Correlation Analysis](3_correlation.qmd), [Principal Component Analysis](3_pca.qmd)). Finally, because HDI includes life expectancy by construction, its bivariate correlation is partly mechanical; we therefore treat it primarily as a descriptive proxy and assess sensitivity in [Investigate HDI](2_investigate_hdi.qmd).


::: {.callout-note collapse="true"}
## Column glossary (from `LECol` metadata)

The table below summarizes column meanings and the default transforms applied later in the pipeline (`tf_and_norm`).

```{python}
# | label: tbl-intro-column-glossary
# | tbl-cap: "Column definitions and default preprocessing transforms."
column_glossary.loc[:, ["pretty", "description", "transform"]].rename(
    columns={
        "pretty": "Feature",
        "description": "Definition (units / scale)",
        "transform": "Default transform",
    },
).style.hide(axis="index")

```
:::
